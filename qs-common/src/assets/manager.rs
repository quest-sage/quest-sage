use std::hash::Hash;
use std::sync::{Arc, Weak};
use tokio::sync::RwLock;
use std::collections::HashMap;

/// Represents a globally unique asset ID.
/// These can be generated by calling `new_asset_id`.
type AssetID = u64;

static COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(1);
fn new_asset_id() -> AssetID {
    COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed)
}

/// The asset manager stores assets (like textures) by a simple key-value map.
/// The specific keys used depend on the type parameter to this asset manager.
/// If the asset is not loaded, it is queued to be loaded on a background thread.
pub struct AssetManager<K, T, L>
where
    K: Eq + Hash + Send + Clone + 'static,
    T: Send + Sync + 'static,
    L: Loader<K, T> + Send + Sync + 'static,
{
    /// The assets store references to the asset data, which is owned by stored_assets.
    assets: HashMap<K, Asset<T>>,
    /// Store the actual asset data. The assets are deleted automatically when the asset manager is dropped.
    /// Weak references to these `Arc`s are stored in each asset.
    stored_assets: HashMap<AssetID, Arc<RwLock<LoadStatus<T>>>>,
    asset_loader: Arc<L>,
}

impl<K, T, L> AssetManager<K, T, L>
where
    K: Eq + Hash + Send + Clone + 'static,
    T: Send + Sync + 'static,
    L: Loader<K, T> + Send + Sync + 'static,
{
    pub fn new(loader: L) -> Self {
        Self {
            assets: HashMap::new(),
            stored_assets: HashMap::new(),
            asset_loader: Arc::new(loader),
        }
    }

    fn on_load(data: &mut LoadStatus<T>, loaded: Result<T, LoadError>) -> LoadStatus<T> {
        if let LoadStatus::Loading(load, fail) = data {
            // This if-let should never fail, because any asset should only be loaded once.
            match loaded {
                Ok(mut value) => {
                    // Call all load functions, moving them out of the original load status.
                    for function in load.drain(..) {
                        function(&mut value);
                    }
                    LoadStatus::Loaded(value)
                }
                Err(error) => {
                    // Call all fail functions, moving them out of the original load status.
                    for function in fail.drain(..) {
                        function(&error);
                    }
                    LoadStatus::Failed(error)
                }
            }
        } else {
            LoadStatus::Failed(LoadError::MultiplyLoaded)
        }
    }

    /// Retrieves the asset with the given key. If the asset was not loaded, it will be
    /// loaded on a background task without blocking the main thread.
    pub fn get(&mut self, k: K) -> Asset<T> {
        let k1 = k.clone();
        let entry = self.assets.entry(k1);
        let stored_assets = &mut self.stored_assets;
        let loader = Arc::clone(&self.asset_loader);
        entry
            .or_insert_with(|| {
                let id = new_asset_id();
                let data = Arc::new(RwLock::new(LoadStatus::Loading(Vec::new(), Vec::new())));

                let asset = Asset::<T> {
                    id,
                    data: Arc::downgrade(&data),
                };

                stored_assets.insert(id, Arc::clone(&data));
                tokio::spawn(async move {
                    let loaded = loader.load(k).await;
                    let mut data = data.write().await;
                    *data = AssetManager::<K, T, L>::on_load(&mut *data, loaded);
                });
                asset
            })
            .clone()
    }
}

/// Represents an asset that is being loaded on a background thread.
/// Note that the asset is only valid for the lifetime of the asset manager that owns it.
/// You can clone the asset without cloning the underlying data. This will simply create
/// another reference to the same data.
pub struct Asset<T> {
    /// A globally unique identifier.
    id: AssetID,
    /// A reference to the underlying data for this asset.
    /// If this cannot be promoted to an `Arc`, the asset manager owning this asset has been deleted.
    pub data: Weak<RwLock<LoadStatus<T>>>,
}

impl<T> std::fmt::Debug for Asset<T> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "asset {}", self.id)
    }
}

impl<T> PartialEq for Asset<T> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl<T> Eq for Asset<T> {}

impl<T> Clone for Asset<T> {
    fn clone(&self) -> Self {
        Self {
            id: self.id,
            data: Weak::clone(&self.data),
        }
    }
}

// TODO: Test these on_load and on_fail methods!
impl<T> Asset<T> {
    /// When the asset has finished loading, call this function on it.
    /// If the asset is already loaded, the function will be called synchronously on this thread.
    ///
    /// The function here should be very lightweight; this could cause other threads to block while the function is running if they're waiting for
    /// access to this asset!
    pub async fn on_load(&self, func: impl FnOnce(&mut T) + Send + Sync + 'static) {
        if let Some(data) = self.data.upgrade() {
            match &mut *data
                .write().await
            {
                LoadStatus::Loading(load, _) => load.push(Box::new(func)),
                LoadStatus::Loaded(t) => func(t),
                LoadStatus::Failed(_) => {}
            }
        }
    }

    /// When the asset has finished loading, call this function on it if the load fails.
    /// If the asset has already failed loading, the function will be called synchronously on this thread.
    ///
    /// The function here should be very lightweight; this could cause other threads to block while the function is running if they're waiting for
    /// access to this asset!
    pub async fn on_fail(&self, func: impl FnOnce(&LoadError) + Send + Sync + 'static) {
        if let Some(data) = self.data.upgrade() {
            match &mut *data
                .write().await
            {
                LoadStatus::Loading(_, fail) => fail.push(Box::new(func)),
                LoadStatus::Loaded(_) => {}
                LoadStatus::Failed(e) => func(e),
            }
        }
    }

    /// If the asset is loaded, run this function on it.
    /// Returns true if the asset was loaded.
    pub async fn if_loaded(&self, func: impl FnOnce(&T)) -> bool {
        if let Some(data) = self.data.upgrade() {
            match &*data.read().await {
                LoadStatus::Loading(_, _) => {}
                LoadStatus::Loaded(value) => func(value),
                LoadStatus::Failed(_) => {}
            }
            true
        } else {
            false
        }
    }

    /// Waits for the asset to be loaded (or until the load fails).
    pub async fn wait_until_loaded_or_failed(&self) {
        let (tx, mut rx) = tokio::sync::mpsc::channel(1);
        let tx2 = tx.clone();
        self.on_load(move |_| { futures::executor::block_on(tx.send(())).expect("asset load/fail detection channel was unexpectedly dropped (tx 1)"); }).await;
        self.on_fail(move |_| { futures::executor::block_on(tx2.send(())).expect("asset load/fail detection channel was unexpectedly dropped (tx 2)"); }).await;
        rx.recv().await.expect("asset load/fail detection channel was unexpectedly dropped (rx), this could be because the asset manager was dropped");
    }

    /// Waits for the asset to be loaded. If the load fails, this panics.
    pub async fn wait_until_loaded(&self) {
        let (tx, rx) = tokio::sync::oneshot::channel();
        self.on_load(move |_| { tx.send(()).expect("asset load detection channel was unexpectedly dropped (tx)"); }).await;
        rx.await.expect("asset load detection channel was unexpectedly dropped (rx), this could be because the asset failed to load or because the asset manager was dropped");
    }
}

/// A function to be called when an asset has just been loaded.
type OnLoadFunc<T> = Box<dyn FnOnce(&mut T) + Send + Sync + 'static>;
/// A function to be called when an asset has just failed to load.
type OnFailFunc = Box<dyn FnOnce(&LoadError) + Send + Sync + 'static>;

/// Tells us whether an asset is currently being loaded, whether it has finished being loaded,
/// or if it could not be loaded for whatever reason.
pub enum LoadStatus<T> {
    /// This asset is currently being loaded on a background thread.
    /// When the asset has just loaded, all of the `OnLoadFunc` will be called.
    /// If the asset could not be loaded for whatever reason, all of the `OnFailFunc` will be called.
    Loading(Vec<OnLoadFunc<T>>, Vec<OnFailFunc>),
    /// The asset has been loaded.
    Loaded(T),
    /// This asset could not be loaded.
    Failed(LoadError),
}

pub enum LoadError {
    /// The file that the asset is contained within could not be found.
    FileNotFound,
    /// The file that the asset is contained within could not be read.
    FileNotReadable,
    /// The provided asset data, for example the contents of a file, were invalid.
    InvalidData,
    /// This should never be seen. This indicates that the asset has been loaded twice.
    MultiplyLoaded,
}

/// Tells us how to load an asset. This `load` function will be called on a background thread, using `tokio::spawn`.
/// So don't do blocking calls or normal blocking Rust io, use asynchronous IO instead.
/// To implement this `async_trait`, make sure to use the `async_trait` proc macro on your impl.
#[async_trait::async_trait]
pub trait Loader<K, T> {
    async fn load(&self, key: K) -> Result<T, LoadError>;
}

/// Represents an asset that owns its data. Use this when you need to pass in an asset,
/// but don't want to have it loaded in an asset manager. Extremely lightweight.
pub struct OwnedAsset<T> {
    _owned_data: Arc<RwLock<LoadStatus<T>>>,
    asset: Asset<T>,
}

impl<T> OwnedAsset<T> {
    pub fn new(asset: T) -> Self {
        let owned = Arc::new(RwLock::new(LoadStatus::Loaded(asset)));
        let data = Arc::downgrade(&owned);
        OwnedAsset {
            _owned_data: owned,
            asset: Asset {
                id: new_asset_id(),
                data,
            },
        }
    }
}

impl<T> std::ops::Deref for OwnedAsset<T> {
    type Target = Asset<T>;

    fn deref(&self) -> &Self::Target {
        &self.asset
    }
}
