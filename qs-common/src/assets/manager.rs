use std::collections::HashMap;
use std::hash::Hash;
use std::sync::{Arc, RwLock, Weak};

/// Represents a globally unique asset ID.
/// These can be generated by calling `new_asset_id`.
type AssetID = u64;

static COUNTER: std::sync::atomic::AtomicU64 = std::sync::atomic::AtomicU64::new(1);
fn new_asset_id() -> AssetID {
    COUNTER.fetch_add(1, std::sync::atomic::Ordering::Relaxed)
}

/// The asset manager stores assets (like textures) by a simple key-value map.
/// The specific keys used depend on the type parameter to this asset manager.
/// If the asset is not loaded, it is queued to be loaded on a background thread.
pub struct AssetManager<K, T, L>
where
    K: Eq + Hash + Send + Clone + 'static,
    T: Send + Sync + 'static,
    L: Loader<K, T> + Send + Sync + 'static,
{
    /// The assets store references to the asset data, which is owned by stored_assets.
    assets: HashMap<K, Asset<T>>,
    /// Store the actual asset data. The assets are deleted automatically when the asset manager is dropped.
    /// Weak references to these `Arc`s are stored in each asset.
    stored_assets: HashMap<AssetID, Arc<RwLock<LoadStatus<T>>>>,
    asset_loader: Arc<L>,
}

impl<K, T, L> AssetManager<K, T, L>
where
    K: Eq + Hash + Send + Clone + 'static,
    T: Send + Sync + 'static,
    L: Loader<K, T> + Send + Sync + 'static,
{
    pub fn new(loader: L) -> Self {
        Self {
            assets: HashMap::new(),
            stored_assets: HashMap::new(),
            asset_loader: Arc::new(loader),
        }
    }

    pub fn get(&mut self, k: K) -> &Asset<T> {
        let k1 = k.clone();
        let entry = self.assets.entry(k1);
        let stored_assets = &mut self.stored_assets;
        let loader = Arc::clone(&self.asset_loader);
        entry.or_insert_with(|| {
            let id = new_asset_id();
            let data = Arc::new(RwLock::new(LoadStatus::Loading));

            let asset = Asset::<T> {
                id,
                data: Arc::downgrade(&data),
            };

            stored_assets.insert(id, Arc::clone(&data));
            tokio::spawn(async move {
                let loaded = loader.load(k).await;
                let mut data = data.write().unwrap();
                *data = match loaded {
                    Ok(value) => LoadStatus::Loaded(value),
                    Err(error) => LoadStatus::Failed(error),
                }
            });
            asset
        })
    }
}

/// Represents an asset that is being loaded on a background thread.
/// Note that the asset is only valid for the lifetime of the asset manager that owns it.
/// You can clone the asset without cloning the underlying data. This will simply create
/// another reference to the same data.
pub struct Asset<T> {
    /// A globally unique identifier.
    id: AssetID,
    /// A reference to the underlying data for this asset.
    /// If this cannot be promoted to an `Arc`, the asset manager owning this asset has been deleted.
    pub data: Weak<RwLock<LoadStatus<T>>>,
}

impl<T> PartialEq for Asset<T> {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl<T> Eq for Asset<T> {}

impl<T> Clone for Asset<T> {
    fn clone(&self) -> Self {
        Self {
            id: self.id,
            data: Weak::clone(&self.data),
        }
    }
}

/// Tells us whether an asset is currently being loaded, whether it has finished being loaded,
/// or if it could not be loaded for whatever reason.
pub enum LoadStatus<T> {
    /// This asset is currently being loaded on a background thread.
    Loading,
    /// The asset has been loaded.
    Loaded(T),
    /// This asset could not be loaded.
    Failed(LoadError),
}

pub enum LoadError {
    FileNotFound,
    FileNotReadable,
    InvalidData,
}

/// Tells us how to load an asset. This `load` function will be called on a background thread, using `tokio::spawn`.
/// So don't do blocking calls or normal blocking Rust io, use asynchronous IO instead.
/// To implement this `async_trait`, make sure to use the `async_trait` proc macro on your impl.
#[async_trait::async_trait]
pub trait Loader<K, T> {
    async fn load(&self, key: K) -> Result<T, LoadError>;
}
